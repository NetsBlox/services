const { dec2Bin, printBinary, ensureNBits, asciiToBits, chopString, binaryToAsciiChar } = require('./utils');

/*
* fiestel block encryption helper
* relies heavily on javascripts charCodeAt and fromCharCode.
* assumes 8bit ascii alphabet
*/
class BlockCipher {
  /*
  * @param {Number} n word size in bits
  * @param {Number} m number of keywords
  */
  constructor(n, m, numRounds) {
    if (!n || !m || !numRounds) throw new Error('missing initialization parameters');
    console.log(`creating block cipher with block size: ${2*n} key size: ${m*n}`);
    this.m = m;
    this.n = n;
    this.numRounds = numRounds;
    this.MAX_KEY = Math.pow(2, m * n);
    this.MAX_WORD = Math.pow(2, n);
    this.ALPHABET_SIZE = 8;
  }

  _checkKeyWords(keyWords) {
    if (!Array.isArray(keyWords) || keyWords.length !== this.m) throw new Error('bad key words');
    keyWords.forEach(key => {
      if (isNaN(key) || key > this.MAX_WORD) throw new Error('bad key word', key);
    })
  }

  /*
  * @param {Array<Number>} keyWords a list of key words containing numbers up to word size
  * @returns {Array<Number>} round keys: a list of round keys
  */
  _expandKey(keyWords) {
    this._checkKeyWords(keyWords);
    // override
  }

  /*
  * @param {Array<Number>} words a list of 2 words (a block)
  * @param {Array<Number>} rKeys: a list of round keys
  */
  _encrypt(words, rKeys) {
    // override
    throw new Error('not implemented');
  }

  /*
  * @param {Array<Number>} words a list of 2 words (a block)
  * @param {Array<Number>} rKeys: a list of round keys
  */
  _decrypt(words, rKeys) {
    // override
    throw new Error('not implemented');
  }

  /*
  * converts text to word sized integer blocks
  * @param {string} text ascii text to encrypt (8bit encoded)
  */
  _textToNumericBlocks(text) {
    // prepare the text
    let bits = asciiToBits(text);
    // console.log(bits);
    let inputWords = chopString(bits, this.n)
      .map(word => parseInt(word, 2));
    // console.log('input words', inputWords);

    // account for odd number of words
    if (inputWords.length % 2 !== 0) inputWords.push(0);

    let blocks = []
    while (inputWords.length) {
      blocks.push([inputWords.shift(), inputWords.shift()]);
    }
    return blocks;
  }

  /*
  * converts word sized integer blocks to text
  * WARN drops null characters \u0000
  * @param {Array<Number>} encWords converts a list of word integers into text
  * @param {Boolean=} removeNulls determines if the null characters should be removed in the process
  */
  _numericBlocksToText(intWords, removeNulls=false) {
    const NULL_CHAR = new Array(this.ALPHABET_SIZE).fill(0).join(''); // initially generated by padding small numbers
    // ensure each word is alphabet size
    let bitsStr =  intWords
      .map(w => dec2Bin(w)) // convert to bin string repr
      .map(w => ensureNBits(w, this.n))
      .join('');

    // convert it back to ascii
    console.assert(bitsStr.length % this.ALPHABET_SIZE === 0);
    let charBitBuckets =  chopString(bitsStr, this.ALPHABET_SIZE);
    if (removeNulls) charBitBuckets = charBitBuckets.filter(charBits => charBits !== NULL_CHAR);

    return charBitBuckets.map(binaryChar => binaryToAsciiChar(binaryChar))
      .join('');
  }

  /*
  * @param {string} text ascii text to encrypt (8bit encoded)
  * @param {Array<Number>} keyWords a list of key words containing numbers up to word size
  */
  encryptAscii(text, keyWords) {
    if (text === undefined) throw new Error('bad input');

    // prepare the round keys
    let roundKeys = this._expandKey(keyWords);
    // console.log(roundKeys);

    let encWords = [];
    let blocks = this._textToNumericBlocks(text);
    blocks.forEach(block => {
      const [encX, encY] = this._encrypt(block, roundKeys);
      if (encX > this.MAX_WORD || encY > this.MAX_WORD) throw new Error('encryptiong returned too big a number');
      encWords.push(encX, encY);
    })

    return this._numericBlocksToText(encWords);
  }

  /*
  * @param {string} text ascii text to encrypt (8bit encoded)
  * @param {Array<Number>} keyWords a list of key words containing numbers each up to word size
  */
  decryptAscii(text, keyWords) {
    if (text === undefined) throw new Error('bad input');

    // prepare the round keys
    let roundKeys = this._expandKey(keyWords);
    // console.log(roundKeys);

    let encWords = [];
    let blocks = this._textToNumericBlocks(text);
    blocks.forEach(block => {
      const [decX, decY] = this._decrypt(block, roundKeys);
      if (decX > this.MAX_WORD || decY > this.MAX_WORD) throw new Error('encryptiong returned too big a number');
      encWords.push(decX, decY);
    })
    // console.log('enc words', encWords);

    return this._numericBlocksToText(encWords, true);
  }
}

module.exports = BlockCipher;
